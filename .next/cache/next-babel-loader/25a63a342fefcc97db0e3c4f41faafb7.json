{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar CV = /*#__PURE__*/function () {\n  function CV() {\n    _classCallCheck(this, CV);\n  }\n\n  _createClass(CV, [{\n    key: \"_dispatch\",\n\n    /**\n     * We will use this method privately to communicate with the worker and\n     * return a promise with the result of the event. This way we can call\n     * the worker asynchronously.\n     */\n    value: function _dispatch(event) {\n      var _this = this;\n\n      var msg = event.msg;\n      this._status[msg] = ['loading'];\n      this.worker.postMessage(event);\n      return new Promise(function (res, rej) {\n        var interval = setInterval(function () {\n          var status = _this._status[msg]; // if (!status || status == undefined) res(true);\n\n          if (status[0] === 'done') {\n            res(status[1]);\n          } else if (status[0] === 'error') rej(status[1]);else if (status[0] !== 'loading') {\n            delete _this._status[msg];\n            clearInterval(interval);\n          }\n        }, 0);\n      });\n    }\n    /**\n     * First, we will load the worker and we will capture the onmessage\n     * and onerror events to know at all times the status of the event\n     * we have triggered.\n     *\n     * Then, we are going to call the 'load' event, as we've just\n     * implemented it so that the worker can capture it.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n\n      this._status = {};\n      this.worker = new Worker('/js/worker.js'); // load worker\n      // Capture events and save [status, event] inside the _status object\n\n      this.worker.onmessage = function (e) {\n        return _this2._status[e.data.msg] = ['done', e];\n      };\n\n      this.worker.onerror = function (e) {\n        return _this2._status[e.data.msg] = ['error', e];\n      };\n\n      return this._dispatch({\n        msg: 'load'\n      });\n    }\n    /**\n     * We are going to use the _dispatch event that we created before to\n     * call the postMessage with the msg and the image as payload.\n     *\n     * Thanks to what we have implemented in the _dispatch, this will\n     * return a promise with the processed image.\n     */\n\n  }, {\n    key: \"imageProcessing\",\n    value: function imageProcessing(payload) {\n      return this._dispatch({\n        msg: 'imageProcessing',\n        payload: payload\n      });\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(payload) {\n      return this._dispatch({\n        msg: 'predict',\n        payload: payload\n      });\n    }\n  }]);\n\n  return CV;\n}(); // Export the same instant everywhere\n\n\nexport default new CV();","map":{"version":3,"sources":["E:/Signify-master/services/service.js"],"names":["CV","event","msg","_status","worker","postMessage","Promise","res","rej","interval","setInterval","status","clearInterval","Worker","onmessage","e","data","onerror","_dispatch","payload"],"mappings":";;;IAAMA,E;;;;;;;;AACJ;AACF;AACA;AACA;AACA;8BACYC,K,EAAO;AAAA;;AAAA,UACPC,GADO,GACCD,KADD,CACPC,GADO;AAEf,WAAKC,OAAL,CAAaD,GAAb,IAAoB,CAAC,SAAD,CAApB;AACA,WAAKE,MAAL,CAAYC,WAAZ,CAAwBJ,KAAxB;AACA,aAAO,IAAIK,OAAJ,CAAY,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC/B,YAAIC,QAAQ,GAAGC,WAAW,CAAC,YAAM;AAC/B,cAAMC,MAAM,GAAG,KAAI,CAACR,OAAL,CAAaD,GAAb,CAAf,CAD+B,CAE/B;;AACA,cAAIS,MAAM,CAAC,CAAD,CAAN,KAAc,MAAlB,EAA0B;AACxBJ,YAAAA,GAAG,CAACI,MAAM,CAAC,CAAD,CAAP,CAAH;AACD,WAFD,MAEO,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,OAAlB,EAA2BH,GAAG,CAACG,MAAM,CAAC,CAAD,CAAP,CAAH,CAA3B,KACF,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,SAAlB,EAA6B;AAChC,mBAAO,KAAI,CAACR,OAAL,CAAaD,GAAb,CAAP;AACAU,YAAAA,aAAa,CAACH,QAAD,CAAb;AACD;AACF,SAVyB,EAUvB,CAVuB,CAA1B;AAWD,OAZM,CAAP;AAaD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;2BACS;AAAA;;AACL,WAAKN,OAAL,GAAe,EAAf;AACA,WAAKC,MAAL,GAAc,IAAIS,MAAJ,CAAW,eAAX,CAAd,CAFK,CAEsC;AAE3C;;AACA,WAAKT,MAAL,CAAYU,SAAZ,GAAwB,UAACC,CAAD;AAAA,eAAQ,MAAI,CAACZ,OAAL,CAAaY,CAAC,CAACC,IAAF,CAAOd,GAApB,IAA2B,CAAC,MAAD,EAASa,CAAT,CAAnC;AAAA,OAAxB;;AACA,WAAKX,MAAL,CAAYa,OAAZ,GAAsB,UAACF,CAAD;AAAA,eAAQ,MAAI,CAACZ,OAAL,CAAaY,CAAC,CAACC,IAAF,CAAOd,GAApB,IAA2B,CAAC,OAAD,EAAUa,CAAV,CAAnC;AAAA,OAAtB;;AACA,aAAO,KAAKG,SAAL,CAAe;AAAEhB,QAAAA,GAAG,EAAE;AAAP,OAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;oCACkBiB,O,EAAS;AACvB,aAAO,KAAKD,SAAL,CAAe;AAAEhB,QAAAA,GAAG,EAAE,iBAAP;AAA0BiB,QAAAA,OAAO,EAAPA;AAA1B,OAAf,CAAP;AACD;;;4BAEOA,O,EAAS;AACf,aAAO,KAAKD,SAAL,CAAe;AAAEhB,QAAAA,GAAG,EAAE,SAAP;AAAkBiB,QAAAA,OAAO,EAAPA;AAAlB,OAAf,CAAP;AACD;;;;KAGH;;;AACA,eAAe,IAAInB,EAAJ,EAAf","sourcesContent":["class CV {\n  /**\n   * We will use this method privately to communicate with the worker and\n   * return a promise with the result of the event. This way we can call\n   * the worker asynchronously.\n   */\n  _dispatch(event) {\n    const { msg } = event;\n    this._status[msg] = ['loading'];\n    this.worker.postMessage(event);\n    return new Promise((res, rej) => {\n      let interval = setInterval(() => {\n        const status = this._status[msg];\n        // if (!status || status == undefined) res(true);\n        if (status[0] === 'done') {\n          res(status[1]);\n        } else if (status[0] === 'error') rej(status[1]);\n        else if (status[0] !== 'loading') {\n          delete this._status[msg];\n          clearInterval(interval);\n        }\n      }, 0);\n    });\n  }\n\n  /**\n   * First, we will load the worker and we will capture the onmessage\n   * and onerror events to know at all times the status of the event\n   * we have triggered.\n   *\n   * Then, we are going to call the 'load' event, as we've just\n   * implemented it so that the worker can capture it.\n   */\n  load() {\n    this._status = {};\n    this.worker = new Worker('/js/worker.js'); // load worker\n\n    // Capture events and save [status, event] inside the _status object\n    this.worker.onmessage = (e) => (this._status[e.data.msg] = ['done', e]);\n    this.worker.onerror = (e) => (this._status[e.data.msg] = ['error', e]);\n    return this._dispatch({ msg: 'load' });\n  }\n\n  /**\n   * We are going to use the _dispatch event that we created before to\n   * call the postMessage with the msg and the image as payload.\n   *\n   * Thanks to what we have implemented in the _dispatch, this will\n   * return a promise with the processed image.\n   */\n  imageProcessing(payload) {\n    return this._dispatch({ msg: 'imageProcessing', payload });\n  }\n\n  predict(payload) {\n    return this._dispatch({ msg: 'predict', payload });\n  }\n}\n\n// Export the same instant everywhere\nexport default new CV();\n"]},"metadata":{},"sourceType":"module"}